#!/bin/bash

secure_copy(){
    TARGET=$1
    DESTINATION=$2

    MESSAGE=""
    if [ -e $TARGET ]; then
        scp -oStrictHostKeyChecking=no $TARGET $DESTINATION
        if [ $? -eq 0 ]; then
            rm $TARGET
        else
            MESSAGE="Copy of "$(basename $TARGET)" failed"
        fi
    fi

    echo $MESSAGE
}

MAXNUM=-1
MAXSIZE=2000
NAMEBASE="merged"
MERGEALL=0
while [ $# -ne 3 ]; do
    case $1 in
        -n)
            MAXNUM=$2
            shift
            shift
            ;;
        -s)
            MAXSIZE=$2
            shift
            shift
            ;;
        -o)
            NAMEBASE=$2
            shift
            shift
            ;;
        -A)
            MERGEALL=1
            shift
            ;;
        *)
            shift
            ;;
    esac
done

CMSSW_BASE=$1
DESTINATION=$2
LOGFILE=$3

while true; do
    OUTPUTDIR=/tmp/$USER/$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 6 | head -n 1)
    mkdir $OUTPUTDIR > /dev/null 2>&1 && break
done

echo $HOSTNAME:$OUTPUTDIR

exec 3>&1
exec 1>$LOGFILE 2>&1

echo "hadder $HOSTNAME:$OUTPUTDIR"
echo "CMSSW_BASE $CMSSW_BASE"

CWD=$PWD
cd $CMSSW_BASE
eval `/afs/cern.ch/cms/common/scramv1 runtime -sh` || exit 1
cd $CWD

if [ $MERGEALL -eq 1 ]; then
    # target directory and target name
    TARGETDIR=$OUTPUTDIR/output
    TARGETBASE=$TARGETDIR/${NAMEBASE}
    INDEX=0
    TARGET=${TARGETBASE}_${INDEX}.root
fi

while read -a INPUT; do
    JOBGROUP="${INPUT[0]}"
    ROOTFILE="${INPUT[1]}"

    # blank line -> return
    [ -z "$JOBGROUP" ] && break

    if [ $MERGEALL -eq 0 ]; then
        # target directory and target name
        TARGETDIR=$OUTPUTDIR/$JOBGROUP
        TARGETBASE=$TARGETDIR/${NAMEBASE}_${JOBGROUP}
    fi

    if [ ! -d $TARGETDIR ]; then
        # if the target directory does not exist, create one
        mkdir $TARGETDIR 2>&1 || continue
        echo "0" > $TARGETDIR/merged
        echo "0" > $TARGETDIR/index
    fi

    INDEX=$(cat $TARGETDIR/index)
    TARGET=${TARGETBASE}_${INDEX}.root

    MESSAGE=""

    if [ -z "$ROOTFILE" ]; then
        if [ $MERGEALL -eq 0 ]; then
            # input with only the job group name signals the end or processing for the group
            if [ $INDEX -eq 0 ]; then
                NEWTARGET=${TARGETBASE}.root
                mv $TARGET $NEWTARGET
                TARGET=$NEWTARGET
            fi
            MESSAGE=$(secure_copy $TARGET $DESTINATION)
        fi
    else
        if [ -e $TARGET ]; then
            # target already exists -> do merge and increment the counters
            hadd $TARGETDIR/tmp.root $TARGET $ROOTFILE
            if [ $? -eq 0 ]; then
                mv $TARGETDIR/tmp.root $TARGET
                rm $ROOTFILE

                MERGED=$(($(cat $TARGETDIR/merged) + 1))
                if [ $MERGED -eq $MAXNUM -o $(du -m $TARGET | awk '{print $1}') -gt $MAXSIZE ]; then
                    MESSAGE=$(secure_copy $TARGET $DESTINATION)

                    echo $(($INDEX + 1)) > $TARGETDIR/index
                    echo "0" > $TARGETDIR/merged
                else
                    echo $MERGED > $TARGETDIR/merged
                fi
            else
                rm $TARGETDIR/tmp.root
                MESSAGE="File "$(basename $ROOTFILE)" could not be merged"
            fi
        else
            # create target
            mv $ROOTFILE $TARGET
            echo "1" > $TARGETDIR/merged
        fi
    fi

    echo $MESSAGE >&3
done

if [ $MERGEALL -eq 1 ]; then
    if [ $INDEX -eq 0 ]; then
        NEWTARGET=${TARGETBASE}.root
        mv $TARGET $NEWTARGET
        TARGET=$NEWTARGET
    fi
    MESSAGE=$(secure_copy $TARGET $DESTINATION)
    if [ -z "$MESSAGE" ]; then
        MESSAGE="haddder finished"
    fi
else
    MESSAGE="haddder finished"
fi

exec 1>&3 3>&-
echo $MESSAGE
